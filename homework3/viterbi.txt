维特比算法
维特比算法动态规划算法用于最可能产生观测时间序列的-维特比路径-隐含状态序列，特别是在马尔可夫信息源上下文和隐马尔科夫模型中。术语“维特比路径”和“维特比算法”也被用于寻找观察结果最有可能解释的相关动态规划算法。例如在统计句法分析中动态规划可以被用于发现最有可能的上下文无关的派生的字符串，有时被称为“维特比分析”。
利用动态规划寻找最短路径
动态规划是运筹学的一个分支，是求解决策过程最优化的数学方法，通常情况下应用于最优化的问题，这类问题一般有很多可行的解，每个解有一个值，而我们希望从中找到最优的答案。
在计算机科学领域，应用动态规划的思想解决的最基本的一个问题就是：寻找有向无环图（篱笆网络）当中两个点之间的最短路径（实际应用于地图导航、语音识别、分词、机器翻译等等）
下面举一个比较简单的例子做说明：求S到E的最短路径，如下图（各点之间距离不相同）：
 
 
我们知道，要找到S到E之间最短路径，最容易想到的方法就是穷举法。也就是把所有可能的路径都例举出来。从S走向A层共有4种走法，从A层走向B层又有4种走法，从B层走向C层又有4种走法，然后C层走向E点只有一种选择。所以最终我们穷举出了4*4*4=64种可能。显然，这种方法必定可行，但在实际的应用当中，对于数量及其庞大的节点数和边数的图，其计算复杂度也将会变得非常大，而计算效率也会随之降低。
 
 
因此，这里选择适用一种基于动态规划的方式来寻找最佳路径。
所谓动态规划。其核心就是“动态”的概念，把大的问题细分为多个小的问题，基于每一步的结果再去寻找下一步的策略，通过每一步走过之后的局部最优去寻找全局最优，这样解释比较抽象，下面直接用回刚刚的例子说明。如下图：
 
 
首先，我们假设S到E之间存在一条最短路径（红色），且这条路径经过C2点，那么我们便一定能够确定从S到C2的64条（4*4*4=64）子路经当中，该子路经一定最短。（证明：反证法。如果S到C2之间存在一条更短的子路经，那么便可以用它来替代原先的路径，而原来的路径显然就不是最短了，这与原假设自相矛盾）。
同理，我们也可以得出从S到B2点为两点间最短子路经的结论。这时候，真相便慢慢浮出水面：既然如此，我们计算从S点出发到点C2的最短路径，是不是只要考虑从S出发到B层所有节点的最短路径就可以了？答案是肯定的！因为，从S到E的“全局最短”路径必定经过这些“局部最短”子路经。没错！这就是上面提及到的通过局部最优的最优去寻找全局最优，问题的规模被不断缩小！
接下来，要揭晓答案了！继续看下图：
 
 
回顾之前的分析：我们计算从S到C2点的最短路径时候只需要考虑从S出发到B层所有节点的最短路径，B层也是。对B2来说，一共有4条路线可达，分别是A1->B2,A2->B2,A3->B2, A4->B2。我们需要做的就是A2->B2这条路线保留，而其他3条删掉（因为根据以上的分析，他们不可能构成全程的最短路线）。Ok，来到这里，我们会发现一个和小“漏洞”，这段S->A2->B2->C2->E的路线只是我一厢情愿的假设，最短路径下不一定是经过以上这些点。所以，我们要把每层的每个节点都考虑进来。
以下是具体做法：
第一步：从点S出发。对于第一层的4个节点，算出他们的距离d(S,A1),d(S,A2),d(S,A3),d(S,A4),因为只有一步，所以这些距离都是S到它们各自的最短距离
第二步:对于B层的所有节点(B1,B2,B3,B4),要计算出S到他们的最短距离。我们知道，对于特定的节点B2，从S到它的路径可以经过A层的任何一个节点(A1,A2,A3,A4)。对应的路径长就是d(S,B2)=d(S,Ai)+d(Ai,B2)（其中i=1，2，3，4）。由于A层有4个节点（即i有4个取值），我们要一一计算，然后找到最小值。这样，对于B层的每个节点，都需要进行4次运算，而B层有4个节点，所以共有4*4=16次运算。
第三步:这一步是该算法的核心。我们从step2计算得出的阶段结果只保留4个最短路径值（每个节点保留一个）。那么，若从B层走向C层来说，该步骤的级数已经不再是4*4，而是变成4！也就是说，从B层到C层的最短路径只需要基于B层得出的4个结果来计算。这种方法一直持续到最后一个状态，每一步计算的复杂度为相邻两层的计算复杂度为4*4乘积的正比！再通俗点说，连接着两两相邻层的计算符合变成了“+”号，取代了原先的“*”号。用这种方法，只需要进行4*4*2=32次计算！
其实上述的算法就是著名的维特比算法，事实上非常简单！
若假设整个网格的宽度为D，网格长度为N，那么弱适用穷举法整个最短路径的算法复杂度为O(D^N),而适用这种算法的计算复杂度为O（ND^2）.试想一下，弱D与N都非常大，适用维特比算法的效率将会提高几个数量级！
